{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\n\nvar _router = require(\"../next-server/lib/router/router\");\n\nvar _escapePathDelimiters = _interopRequireDefault(require(\"../next-server/lib/router/utils/escape-path-delimiters\"));\n\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"./../next-server/lib/router/utils/get-asset-path-from-route\"));\n\nvar _isDynamic = require(\"./../next-server/lib/router/utils/is-dynamic\");\n\nvar _parseRelativeUrl = require(\"./../next-server/lib/router/utils/parse-relative-url\");\n\nvar _querystring = require(\"./../next-server/lib/router/utils/querystring\");\n\nvar _routeMatcher = require(\"./../next-server/lib/router/utils/route-matcher\");\n\nvar _routeRegex = require(\"./../next-server/lib/router/utils/route-regex\");\n\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\n\nfunction pageLoadError(route) {\n  return (0, _router.markLoadingError)(new Error(\"Error loading \".concat(route)));\n}\n\nvar relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' : // https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nvar hasNoModule = ('noModule' in document.createElement('script'));\n\nvar requestIdleCallback = window.requestIdleCallback || function (cb) {\n  return setTimeout(cb, 1);\n};\n/** @param {string} route */\n\n\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(\"Route name should start with a \\\"/\\\", got \\\"\".concat(route, \"\\\"\"));\n  }\n\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\n\nfunction appendLink(href, rel, as) {\n  return new Promise((res, rej, link) => {\n    link = document.createElement('link');\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.href = href;\n    link.rel = rel;\n    if (as) link.as = as;\n    link.onload = res;\n    link.onerror = rej;\n    document.head.appendChild(link);\n  });\n}\n\nclass PageLoader {\n  constructor(buildId, assetPrefix, initialPage) {\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.pageRegisterEvents = (0, _mitt.default)();\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true\n    }; // TODO: get rid of this limitation for rendering the error page\n\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true;\n    }\n\n    if (true) {\n      this.promisedBuildManifest = new Promise(resolve => {\n        if (window.__BUILD_MANIFEST) {\n          resolve(window.__BUILD_MANIFEST);\n        } else {\n          window.__BUILD_MANIFEST_CB = () => {\n            resolve(window.__BUILD_MANIFEST);\n          };\n        }\n      });\n    }\n    /** @type {Promise<Set<string>>} */\n\n\n    this.promisedSsgManifest = new Promise(resolve => {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        window.__SSG_MANIFEST_CB = () => {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  } // Returns a promise for the dependencies for a particular route\n\n\n  getDependencies(route) {\n    return this.promisedBuildManifest.then(m => {\n      var _this$pageRegisterEve;\n\n      return m[route] ? m[route].map(url => \"\".concat(this.assetPrefix, \"/_next/\").concat(encodeURI(url))) : (_this$pageRegisterEve = this.pageRegisterEvents.emit(route, {\n        error: pageLoadError(route)\n      })) != null ? _this$pageRegisterEve : [];\n    });\n  }\n  /**\n  * @param {string} href the route href (file-system path)\n  * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n  */\n\n\n  getDataHref(href, asPath, ssg) {\n    var {\n      pathname: hrefPathname,\n      searchParams,\n      search\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    var query = (0, _querystring.searchParamsToUrlQuery)(searchParams);\n    var {\n      pathname: asPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(asPath);\n    var route = normalizeRoute(hrefPathname);\n\n    var getHrefForSlug =\n    /** @type string */\n    path => {\n      var dataRoute = (0, _getAssetPathFromRoute.default)(path, '.json');\n      return (0, _router.addBasePath)(\"/_next/data/\".concat(this.buildId).concat(dataRoute).concat(ssg ? '' : search));\n    };\n\n    var isDynamic = (0, _isDynamic.isDynamicRoute)(route),\n        interpolatedRoute;\n\n    if (isDynamic) {\n      var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);\n      var dynamicGroups = dynamicRegex.groups;\n      var dynamicMatches = // Try to match the dynamic route against the asPath\n      (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) || // Fall back to reading the values from the href\n      // TODO: should this take priority; also need to change in the router.\n      query;\n      interpolatedRoute = route;\n\n      if (!Object.keys(dynamicGroups).every(param => {\n        var value = dynamicMatches[param] || '';\n        var {\n          repeat,\n          optional\n        } = dynamicGroups[param]; // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n\n        var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n\n        if (optional) {\n          replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n        }\n\n        if (repeat && !Array.isArray(value)) value = [value];\n        return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present\n        interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(_escapePathDelimiters.default).join('/') : (0, _escapePathDelimiters.default)(value)) || '/');\n      })) {\n        interpolatedRoute = ''; // did not satisfy all requirements\n        // n.b. We ignore this error because we handle warning for this case in\n        // development in the `<Link>` component directly.\n      }\n    }\n\n    return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n  }\n  /**\n  * @param {string} href the route href (file-system path)\n  * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n  */\n\n\n  prefetchData(href, asPath) {\n    var {\n      pathname: hrefPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    var route = normalizeRoute(hrefPathname);\n    return this.promisedSsgManifest.then((s, _dataHref) => {\n      requestIdleCallback(() => {\n        // Check if the route requires a data file\n        s.has(route) && ( // Try to generate data href, noop when falsy\n        _dataHref = this.getDataHref(href, asPath, true)) && // noop when data has already been prefetched (dedupe)\n        !document.querySelector(\"link[rel=\\\"\".concat(relPrefetch, \"\\\"][href^=\\\"\").concat(_dataHref, \"\\\"]\")) && // Inject the `<link rel=prefetch>` tag for above computed `href`.\n        appendLink(_dataHref, relPrefetch, 'fetch');\n      });\n    });\n  }\n\n  loadPage(route) {\n    route = normalizeRoute(route);\n    return new Promise((resolve, reject) => {\n      // If there's a cached version of the page, let's use it.\n      var cachedPage = this.pageCache[route];\n\n      if (cachedPage) {\n        var {\n          error,\n          page,\n          mod\n        } = cachedPage;\n        error ? reject(error) : resolve({\n          page,\n          mod\n        });\n        return;\n      }\n\n      var fire = (_ref) => {\n        var {\n          error,\n          page,\n          mod\n        } = _ref;\n        this.pageRegisterEvents.off(route, fire);\n        delete this.loadingRoutes[route];\n\n        if (error) {\n          reject(error);\n        } else {\n          resolve({\n            page,\n            mod\n          });\n        }\n      }; // Register a listener to get the page\n\n\n      this.pageRegisterEvents.on(route, fire);\n\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true;\n\n        if (true) {\n          this.getDependencies(route).then(deps => {\n            deps.forEach(d => {\n              if (d.endsWith('.js') && !document.querySelector(\"script[src^=\\\"\".concat(d, \"\\\"]\"))) {\n                this.loadScript(d, route);\n              }\n\n              if (d.endsWith('.css') && !document.querySelector(\"link[rel=stylesheet][href^=\\\"\".concat(d, \"\\\"]\"))) {\n                appendLink(d, 'stylesheet').catch(() => {// FIXME: handle failure\n                  // Right now, this is needed to prevent an unhandled rejection.\n                });\n              }\n            });\n          });\n        } else {\n          // Development only. In production the page file is part of the build manifest\n          route = normalizeRoute(route);\n          var scriptRoute = (0, _getAssetPathFromRoute.default)(route, '.js');\n          var url = \"\".concat(this.assetPrefix, \"/_next/static/chunks/pages\").concat(encodeURI(scriptRoute));\n          this.loadScript(url, route);\n        }\n      }\n    });\n  }\n\n  loadScript(url, route) {\n    var script = document.createElement('script');\n\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module';\n    }\n\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    script.src = url;\n\n    script.onerror = () => {\n      this.pageRegisterEvents.emit(route, {\n        error: pageLoadError(url)\n      });\n    };\n\n    document.body.appendChild(script);\n  } // This method if called by the route code.\n\n\n  registerPage(route, regFn) {\n    var register = () => {\n      try {\n        var mod = regFn();\n        var pageData = {\n          page: mod.default || mod,\n          mod\n        };\n        this.pageCache[route] = pageData;\n        this.pageRegisterEvents.emit(route, pageData);\n      } catch (error) {\n        this.pageCache[route] = {\n          error\n        };\n        this.pageRegisterEvents.emit(route, {\n          error\n        });\n      }\n    };\n\n    if (false) {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/vercel/next.js/pull/1511\n      if (module.hot && module.hot.status() !== 'idle') {\n        console.log(\"Waiting for webpack to become \\\"idle\\\" to initialize the page: \\\"\".concat(route, \"\\\"\"));\n\n        var check = status => {\n          if (status === 'idle') {\n            module.hot.removeStatusHandler(check);\n            register();\n          }\n        };\n\n        module.hot.status(check);\n        return;\n      }\n    }\n\n    register();\n  }\n  /**\n  * @param {string} route\n  * @param {boolean} [isDependency]\n  */\n\n\n  prefetch(route, isDependency) {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    var cn;\n\n    if (cn = navigator.connection) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n    }\n    /** @type {string} */\n\n\n    var url;\n\n    if (isDependency) {\n      url = route;\n    } else {\n      if (false) {\n        route = normalizeRoute(route);\n        var ext = process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js';\n        var scriptRoute = (0, _getAssetPathFromRoute.default)(route, ext);\n        url = \"\".concat(this.assetPrefix, \"/_next/static/\").concat(encodeURIComponent(this.buildId), \"/pages\").concat(encodeURI(scriptRoute));\n      }\n    }\n\n    return Promise.all(document.querySelector(\"link[rel=\\\"\".concat(relPrefetch, \"\\\"][href^=\\\"\").concat(url, \"\\\"]\")) ? [] : [url && appendLink(url, relPrefetch, url.endsWith('.css') ? 'style' : 'script'), true && !isDependency && this.getDependencies(route).then(urls => Promise.all(urls.map(dependencyUrl => this.prefetch(dependencyUrl, true))))]).then( // do not return any data\n    () => {}, // swallow prefetch errors\n    () => {});\n  }\n\n}\n\nexports.default = PageLoader;","map":null,"metadata":{},"sourceType":"script"}